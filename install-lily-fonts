#!/usr/bin/env python

# -*- coding:utf-8 -*-

from __future__ import unicode_literals

import os
import sys
import shutil
import zipfile

from util.config import Config
from util.fonts import Fonts
from util import error


class LilyPond(object):
    """Represents a given LilyPond installation directory"""

    def install_font(self, f_rec):
        """Installs the given font to the current LilyPond installation."""

        def clear_directory(type, font_filename):
            """Remove existing links to a font in a dir to prevent inconsistencies"""
            target_dir = os.path.join(self.font_dir, type)
            for ln in os.listdir(target_dir):
                abs_ln = os.path.join(target_dir, ln)
                if os.path.islink(abs_ln) and ln.startswith(font_filename):
                    os.unlink(abs_ln)


        def install_directory(ext, font_filename):
            """Create all the links for one font name"""
            pass


        font_filename = f_rec['dirname']
        font_root = f_rec['font_root']
        clear_directory('otf', font_filename)
        clear_directory('svg', font_filename)
        install_directory()


#    for dirName, subdirList, fileList in os.walk(font_dir):
#        print "Processing dir:", dirName
#        for f in fileList:
#            link_name = ''
#            name, ext = os.path.splitext(f)
#            if ext == '.otf':
#                link_name = os.path.join(otf_dir, f)
#            if ext == '.svg' or ext == '.woff':
#                link_name = os.path.join(svg_dir, f)
#            if link_name:
#                link_target = os.path.join(dirName, f)
#                try:
#                    os.symlink(link_target, link_name)
#                except OSError, e:
#                    print "Could not install font:", link_target
#                    print str(e)
#                print 'Installed:', link_name





class Catalog(object):
    def __init__(self):

        # maintain a sorted list of all font names
        self.__font_list = []

        self.__check_font_catalogs()

    def __check_remote_fonts(self):

        print "Parsing remote font catalog ..."
        result = self.__read_catalog_file(lines)
        print "Successfully updated font catalog:"
        print "  Found {} fonts.".format(len(result))
        return result

    def __check_font_catalogs(self):
        self.__local_fonts = self.__check_local_fonts()
        self.__remote_fonts = self.__check_remote_fonts()

    def __check_local_fonts(self):
        print "Determine local fonts."
        font_catalog = os.path.join(self.font_dir(), FONT_CATALOG_FILE_NAME)
        result = {}
        if os.path.exists(font_catalog):
            with open(font_catalog, 'r') as lines:
                declared_fonts = self.__read_catalog_file(lines)
                for font in declared_fonts:
                    tup = declared_fonts[font]
                    if os.path.exists(os.path.join(self.font_dir(), tup[1])):
                        result[font] = (tup[0], tup[1])
                    else:
                        print "Font declared but not present: \"{}\"".format(font)
                        print tup
        else:
            print "  No catalog file found.\n"
        print "  Found {} fonts.".format(len(result))
        return result

    def __read_catalog_file(self, lines):
        def parse_line(line):
            try:
                lst = line.split()
                return (" ".join(lst[2:]),
                        lst[1],
                        lst[0])
            except:
                print "Illegal line in font catalog file, skipping:\n  {}".format(line)
                return None

        result = {}
        for line in lines.readlines():
            line = line.strip()
            if not line.startswith("#") and len(line) > 0:
                match = parse_line(line)
                if not match:
                    continue
                result[match[0]] = (match[1], match[2])
        return result

    def font_dir(self):
        return self.__font_dir

    def local_fonts(self):
        return self.__local_fonts

    def remote_fonts(self):
        return self.__remote_fonts




def main():
    Config.read_args()
    fonts = Fonts()
    print ''.join(fonts.local_catalog._file_content)
    print ''.join(fonts.remote_catalog._file_content)

    sys.exit(0)

    ##################
    conf = Catalog()
    font_matrix = Fonts(conf)
    font_matrix.download_fonts()
    font_matrix.extract_fonts()
    font_matrix.install_fonts()


# ####################################
# Finally launch the program
if __name__ == "__main__":
    main()


######
# Everything below is old code.
# It is never called ATM, but I leave it here because
# it *may* be necessary to copy some of it.

#    if not check_dirs():
#        usage()
#        sys.exit(1)

#    walk_indir()

def check_dirs():
    """Check if two arguments are given and point to
    valid directories"""
    global font_dir, lily_dir, otf_dir, svg_dir

    if len(sys.argv) < 3:
        return False

    # check the given font directory (only presence)
    font_dir = normalize_dir(sys.argv[1])
    if not font_dir:
        return False

    # check the presence of the given LilyPond directory
    lily_dir = normalize_dir(sys.argv[2])
    if not lily_dir:
        return False

    # check if we have a LilyPond install or custom build dir
    base = 'out' if 'out' in os.listdir(lily_dir) else 'usr'

    font_base_dir = os.path.join(lily_dir,
                                 base,
                                 'share',
                                 'lilypond',
                                 'current',
                                 'fonts')

    otf_dir = os.path.join(font_base_dir, 'otf')
    svg_dir = os.path.join(font_base_dir, 'svg')
    if not os.path.isdir(otf_dir):
        print "Not a LilyPond installation?", lily_dir
        return False

    return True

