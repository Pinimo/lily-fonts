#!/usr/bin/env python

#-*- coding:utf-8 -*-

from __future__ import unicode_literals

import  os
import sys
import shutil
import urllib2
import zipfile

from util import commandline

# Constants:
FONT_HOST = 'http://fonts.openlilylib.org'
FONT_CATALOG_FILE_NAME = 'CATALOG'
FONT_CATALOG_URL = '{}/{}'.format(FONT_HOST, FONT_CATALOG_FILE_NAME)


class LilyPond(object):
    """Represents a given LilyPond installation directory"""
    
    def __init__(self, exec_file):
        # Validity check
        self.__exec_file = self.__check_exec_file(exec_file)

        # Target directories for font "installation"
        self.font_dir = os.path.normpath(os.path.join(self.__exec_file,
                         '..',
                         '..', 
                         'share', 
                         'lilypond', 
                         'current', 
                         'fonts'))
#        self.otf_dir = os.path.join(font_dir, 'otf')
#        self.svg_dir = os.path.join(font_dir, 'svg')
            
    def __check_exec_file(self, file_arg):
        
        # tests when a lily path is given
        if file_arg:
            print "Checking LilyPond installation path, given:\n  {}".format(file_arg)
            # does the argument point to a valid file?
            if os.path.exists(file_arg):
                return file_arg
            # is the argument a relative path to a valid file?
            if not os.path.isabs(file_arg):
               abs_path = os.path.join(os.getcwd(), file_arg)
               print "Not found, checking relative path:\n  {}".format(abs_path)
               if os.path.exists(abs_path):
                   return abs_path
            error("Given LilyPond executable not found:\n  {}".format(file_arg))
            
        # No lily given, try determining automagically
        error("No LilyPond executable given. I'm not smart enough yet. Aborting")
    
    def install_font(self, f_rec):
        """Installs the given font to the current LilyPond installation."""
        
        def clear_directory(type, font_filename):
            """Remove existing links to a font in a dir to prevent inconsistencies"""
            target_dir = os.path.join(self.font_dir, type)
            for ln in os.listdir(target_dir):
                abs_ln = os.path.join(target_dir, ln)
                if os.path.islink(abs_ln) and ln.startswith(font_filename):
                    os.unlink(abs_ln)


        def install_directory(ext, font_filename):
            """Create all the links for one font name"""
            pass

        
        font_filename = f_rec['dirname']
        font_root = f_rec['font_root']
        clear_directory('otf', font_filename)
        clear_directory('svg', font_filename)
        install_directory()
        

#    for dirName, subdirList, fileList in os.walk(font_dir):
#        print "Processing dir:", dirName
#        for f in fileList:
#            link_name = ''
#            name, ext = os.path.splitext(f)
#            if ext == '.otf':
#                link_name = os.path.join(otf_dir, f)
#            if ext == '.svg' or ext == '.woff':
#                link_name = os.path.join(svg_dir, f)
#            if link_name:
#                link_target = os.path.join(dirName, f)
#                try:
#                    os.symlink(link_target, link_name)
#                except OSError, e:
#                    print "Could not install font:", link_target
#                    print str(e)
#                print 'Installed:', link_name
            
        



class Fonts(object):
    """Object dealing with the remote and local fonts"""
    
    def __init__(self, conf):
        self.modified = False
        # Reference to the config and LilyPond objects
        self.conf = conf
        self.lily = conf.lilypond
        self.local_fonts = conf.local_fonts()
        self.local_font_names = [f for f in self.local_fonts]
        self.local_font_names.sort()
        self.remote_fonts = conf.remote_fonts()
        self.remote_font_names = [f for f in self.remote_fonts]
        self.remote_font_names.sort()
        self.__updatable_font_names = []
        
        # Matrix (dictionary) with font names and their properties
        self.matrix = mx = {}
        # Fonts that are declared locally but not available online
        self.stale_font_names = []
        # max display lengths
        max_len_font_name = 0
        max_len_font_filename = 0
        
        # iterate over the remote fonts and fill the dictionary
        for rf in self.remote_font_names:
            ln = len(rf)
            dirname = self.remote_fonts[rf][1]
            lfn = len(dirname)
            max_len_font_name = max(ln,  max_len_font_name)
            max_len_font_filename = max(ln,  max_len_font_filename)
            mx[rf] = {
                'remote_version': self.remote_fonts[rf][0], 
                'local_version': None, 
                'dirname': dirname, 
                'font_root': os.path.join(self.conf.font_dir(), dirname), 
                'loc_archive': os.path.join(self.conf.font_dir(), "{}.zip".format(dirname)), 
                # default to 'install'
                'action': 'install'}
        for lf in self.local_font_names:
            if lf in self.remote_font_names:
                lv = self.local_fonts[lf][0]
                rv = self.remote_fonts[lf][0]
                mx[lf]['local_version'] = lv
                mx[lf]['action'] = self.__check_action(rv, lv)
            else:
                self.stale_font_names.append(lf)
        
        self.__max_len_font_name = max_len_font_name + 1
        self.__max_len_font_filename = max_len_font_filename + 1
        self.display_matrix()
        
        if self.stale_font_names:
            print ("\nThere are local fonts not available online.\n" +
                   "Please check, as it may indicate an error condition.")
            for f in self.stale_font_names:
                print "-", f
        
    
    def __check_action(self, remote, local):
        def version_to_integer(font_version):
            if not font_version:
                return 0
            ver_list = font_version.split('.')
            power = 4
            value = 0
            for elem in ver_list:
                value += int(elem) * 10**power
                power -= 1
            return value
        
        rv = version_to_integer(remote)
        lv = version_to_integer(local)
        if lv == 0:
            return "=> install"
        elif rv > lv:
            return "=> update"
        else:
            return "no action"
        
    def display_matrix(self):
        name_len = self.__max_len_font_name
        header = "Font".ljust(name_len) + " Remote  Local  Operation"
        
        print
        print "Font matrix and determined operations:"
        print header
        print "="*len(header)
        for f in self.remote_font_names:
            fname = f.ljust(name_len)
            rem_v = self.matrix[f]['remote_version']
            loc_v = self.matrix[f]['local_version']
            action = self.matrix[f]['action']
            if not loc_v:
                loc_v = 'NA'
            print fname, rem_v.ljust(7), loc_v.ljust(6), action
        
    def download_fonts(self):
        for f in self.updatable_font_names():
            f_rec = self.matrix[f]
            if not self.modified:
                print "\nDownloading font archives now ..."
            self.modified = True
            try:
                dname = f_rec['dirname']
                url = "{host}/{name}/{name}.zip".format(
                    host = FONT_HOST, 
                    name = dname)
                print "- {} ({}).".format(f, url)
                archive = urllib2.urlopen(url)
                output = open(f_rec['loc_archive'],'wb')
                output.write(archive.read())
                output.close()
                self.matrix[f]['local_version'] = self.matrix[f]['remote_version']
                print "  ... OK"
                
            except Exception, e:
                error("Error downloading font archive {}.\nMessage:\n{}".format(
                        f, str(e)))
        self.write_local_catalog()
        
    def extract_fonts(self):
        def clear_directory(dir):
            if os.path.exists(dir):
                shutil.rmtree(dir)
            os.mkdir(dir)
        
        if len(self.updatable_font_names()) > 0:
            print "\nExtracting downloaded fonts"
        for f in self.updatable_font_names():
            archive = zipfile.ZipFile(self.matrix[f]['loc_archive'], 'r')
            font_dir = os.path.join(self.conf.font_dir(), 
                                    self.matrix[f]['dirname'])
            clear_directory(font_dir)
            archive.extractall(font_dir)
            print "-", f

    def install_fonts(self):
        if not self.updatable_font_names():
            return
        print "\nInstalling downloaded fonts"
        for f in self.updatable_font_names():
            self.lily.install_font(self.matrix[f])
        
    def updatable_font_names(self):
        """Returns a list of all remote font names that
           should be downloaded and installed"""
        if self.__updatable_font_names:
            return self.__updatable_font_names
        result = []
        for f in self.remote_font_names:
            if self.matrix[f]['action'] in ['install', 'update']:
                result.append(f)
        return result
        
    def write_local_catalog(self):
        import datetime
        lines = []
        lines.append("# Local LilyPond font catalog")
        lines.append("# Written by the openLilyLib font installation script")
        lines.append("# {}\n".format(datetime.date.isoformat(datetime.date.today())))
        for f in self.remote_font_names:
            f_rec = self.matrix[f]
            line = ' '.join([f_rec['dirname'].ljust(self.__max_len_font_filename), 
                             f_rec['local_version'].ljust(8), 
                             f])
            lines.append(line)
        fname = os.path.join(self.conf.font_dir(), FONT_CATALOG_FILE_NAME)
        catalog = open(fname, 'w')
        catalog.write('\n'.join(lines))
        catalog.close()
    
class Catalogs(object):
    
    def __init__(self):
        self.__process_args()
        self.__check_font_catalogs()
    
    def __check_remote_fonts(self):
        
        print "Downloading font catalog from {} ...".format(FONT_HOST)
        try:
            lines = urllib2.urlopen(FONT_CATALOG_URL)
        except Exception,  e:
            print "An error occured while accessing the catalog:\n  {}\nAborting".format(str(e))
            sys.exit(1)
        
        print "Parsing remote font catalog ..."
        result = self.__read_catalog_file(lines)
        print "Successfully updated font catalog:"
        print "  Found {} fonts.".format(len(result))
        return result
    
    def __check_font_catalogs(self):
        self.__local_fonts = self.__check_local_fonts()
        self.__remote_fonts = self.__check_remote_fonts()
        
    def __check_font_dir(self, dir):
        if not os.path.isabs(dir):
            dir = os.path.normpath(os.path.join(os.getcwd(), dir))
        if not os.path.isdir(dir):
            msg = ("Font directory argument doesn't " +
                   "point to existing directory:\n  {}".format(dir))
            if self.batch:
                error("{}\nAborting".format(msg))
            else:
                if raw_input("{}\n Do you want to create it (y/anything)? ".format(msg)).lower() == "y":
                    os.makedirs(dir)
                else:
                    print "Aborted by user."
                    sys.exit(1)
                    
        print "\nDetermined font directory:\n  {}".format(dir)
        return dir

    def __check_local_fonts(self):
        print "Determine local fonts."
        font_catalog = os.path.join(self.font_dir(), FONT_CATALOG_FILE_NAME)
        result = {}
        if os.path.exists(font_catalog):
            with open(font_catalog, 'r') as lines:
                declared_fonts = self.__read_catalog_file(lines)
                for font in declared_fonts:
                    tup = declared_fonts[font]
                    if os.path.exists(os.path.join(self.font_dir(), tup[1])):
                        result[font] = (tup[0], tup[1])
                    else:
                        print "Font declared but not present: \"{}\"".format(font)
                        print tup
        else:
            print "  No catalog file found.\n"
        print "  Found {} fonts.".format(len(result))
        return result

    def __read_catalog_file(self, lines):
        def parse_line(line):
            try:
                lst = line.split()
                return (" ".join(lst[2:]), 
                         lst[1], 
                         lst[0])
            except:
                print "Illegal line in font catalog file, skipping:\n  {}".format(line)
                return None

        result = {}
        for line in lines.readlines():
            line = line.strip()
            if not line.startswith("#") and len(line) > 0:
                match = parse_line(line)
                if not match:
                    continue
                result[match[0]] = (match[1], match[2])
        return result
    
    def __process_args(self):
        args = commandline.parse()
        print args
        self.batch = True if args['batch'] else False
        self.force = True if args['force'] else False
        self.lilypond = LilyPond(args['lilypond_executable'])
        self.__font_dir = self.__check_font_dir(args['font_directory'])

    def font_dir(self):
        return self.__font_dir
    
    def local_fonts(self):
        return self.__local_fonts
    
    def remote_fonts(self):
        return self.__remote_fonts




def main():
    
    conf = Catalogs()
    font_matrix = Fonts(conf)
    font_matrix.download_fonts()
    font_matrix.extract_fonts()
    font_matrix.install_fonts()

# ####################################
# Finally launch the program
if __name__ == "__main__":
    main()


######
# Everything below is old code.
# It is never called ATM, but I leave it here because
# it *may* be necessary to copy some of it.

#    if not check_dirs():
#        usage()
#        sys.exit(1)
    
#    walk_indir()
    
def check_dirs():
    """Check if two arguments are given and point to
    valid directories"""
    global font_dir, lily_dir, otf_dir, svg_dir

    if len(sys.argv) < 3:
        return False
        
    # check the given font directory (only presence)
    font_dir = normalize_dir(sys.argv[1])
    if not font_dir:
        return False

    # check the presence of the given LilyPond directory
    lily_dir = normalize_dir(sys.argv[2])
    if not lily_dir:
        return False
    
    # check if we have a LilyPond install or custom build dir
    base = 'out' if 'out' in os.listdir(lily_dir) else 'usr'
        
    font_base_dir = os.path.join(lily_dir, 
                           base, 
                           'share', 
                           'lilypond', 
                           'current', 
                           'fonts')

    otf_dir = os.path.join(font_base_dir, 'otf')
    svg_dir = os.path.join(font_base_dir, 'svg')
    if not os.path.isdir(otf_dir):
        print "Not a LilyPond installation?", lily_dir
        return False

    return True
    
def normalize_dir(path):
    """Returns the normalized absolute path while
    respecting if it is absolute or relative."""
    result = os.path.normpath(path) if os.path.isabs(path) else os.path.normpath(os.path.join(os.getcwd(), path))
    if not os.path.isdir(result):
        print 'Not a directory:', result
        return ''
    return result
    
def walk_indir():
    """Recursively walk through the input dir
    and 'install' symlinks to any found .otf or .svg font files."""
